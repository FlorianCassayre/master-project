\section{Future work}
\label{sec:future-work}

While the original goal of this framework was to propose an opinionated front-end for LISA, we do not exclude the possibility of integrating some useful components directly into LISA (as is, or in a refined version). That includes all the logic for bidirectional parsing and printing (possibly with macros), proof utilities and optimization routines, and a matcher or unifier. It should also be decided whether it would be worth strengthening the kernel to provide support for schematic connectors, which are as we have shown essential elements for unification tasks.

The following subsections expose known limitations of the framework, how they could be addressed and finally a selected list of potential ramifications that could be explored as a sequel to this project.

\subsection{Limitations}

Despite our efforts and the previous iterations, we have discovered a few limitations in the current version of the system and present them here along with a hint for a potential fix.

Unlike the kernel, the front does not have an explicit error reporting system when writing proofs. This means that if a tactic is incorrectly applied the result of the optional will be empty but will not indicate the reason. This lack seriously hinders the usability of the framework as it is more difficult to debug proofs. The reason for such absence is because we have not yet been able to unify the tactic arguments APIs in an elegant way, thus postponing the implementation of such a feature.



% simplification
% dedicate language
% even better matching
% export/import proofs
% proof search
% theorem search (repertoire)
% 

\subsection{Theorem search}

One highly desirable feature would be to perform search on proven statements, usually theorems. Such a feature could automatically eliminate goals, improving the usability of the system. For instance, one is usually not interested in knowing if the theorem $\vdash {?s} = {?s}$ exists with that specific name ${?s}$, but rather to find a theorem of the form $\vdash \_ = \_$ such that both underscores can be instantiated to a term. Although the matcher can already solve this task, it is perhaps too powerful to be reduced to a sub-linear querying algorithm and would have to be run on every candidate. Instead, we would be interested in a weaker version that provides a simple pattern matching language to efficiently find theorems that match a pattern.

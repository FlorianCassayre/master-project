\section{Proof Framework}
\label{sec:proof-framework}

The front-end is a layer that depends on the LISA kernel and strives to provide a higher-level interface to write and organize proofs. While the kernel is assumed to be trusted, the front-end does not make such an hypothesis and can thus be made arbitrarily more sophisticated. The only requirement is for the front-end to be able to reconstruct its proofs in the kernel for them to be checked. We define soundness as the property of a proof in the front to be equivalent to one in the kernel. By the requirement, soundness thus relies on the only assumption that statements in the front are logically equivalent to statements in the kernel.

While the front relies on the kernel, it does not expose it to the user. Instead, it redefines most of the kernel components and provides mappings to for uni or bi-directional translations. The motivation is two-fold. First of all, it allows us to extend the existing functionality. For example, it was decided that the kernel would not provide schematic connectors as they were not strictly needed. On the other hand, the front requires such a functionality for its rules and it is not possible to emulate them at low cost. Alternatively we can also strengthen some features, for instance representing sequents as indexed sequences rather than sets. Additionally we can redefine the method \code{toString} on all of our classes. Secondly, it allows us to enrich the DSL and bring type safety guarantees. Some types in the kernel are (purposely) weak and require runtime checks to ensure safety. Although this was not a main aspect of study in this project, it is certainly desirable and contributes to building a strong framework.

The interaction between the front and the kernel is relatively limited as the front handles its own state independently. The common ground between the two are justified statements (axioms, theorems, definitions), which means that such objects can be converted back and forth. Whenever a theorem is proven in the front, it is translated to the kernel and checked for consistency. The front obtains the mirror of that justified statement.

\subsection{Implementation}

The implementation was done in Scala version 3\footnote{Also known as Dotty: \href{https://dotty.epfl.ch}{dotty.epfl.ch}.}. This was constrained by the decision to upgrade LISA from version 2 to 3. However some of the feature that were implemented in this project would not have an equivalent encoding in the previous version, which allows us to confidently argue that Scala version 3 is an appropriate language for the design of DSL libraries.

During the implementation, some bugs were discovered in different areas of the compiler. All the issues that could be minimized and reproduced were reported\footnote{
lampepfl/dotty:
\href{https://github.com/lampepfl/dotty/issues/14667}{\#14667},\
\href{https://github.com/lampepfl/dotty/issues/14707}{\#14707},\
\href{https://github.com/lampepfl/dotty/issues/14765}{\#14765},\
\href{https://github.com/lampepfl/dotty/issues/14818}{\#14818},\
\href{https://github.com/lampepfl/dotty/issues/14834}{\#14834},\
\href{https://github.com/lampepfl/dotty/issues/14858}{\#14858},\
\href{https://github.com/lampepfl/dotty/issues/14907}{\#14907}, and\
\href{https://github.com/lampepfl/dotty/issues/15145}{\#15145}.\
% scalameta/scalameta:
% \href{https://github.com/scalameta/scalameta/issues/2741}{\#2741}
}; most of them have since been fixed or are in the process of getting fixed.

\subsection{Direction}

LCF-like proof systems are notorious for the simplicity of their implementation, which makes it a desirable foundational system [citation needed]. However they also become a limiting factor in terms of usability, assuming they are used bare (that is without an overlay). For example incomplete proofs cannot be constructed, although those are useful in practice. Another example, which is a consequence of the first: proofs must be constructed in the forward direction only, meaning that the conclusion is dictated by the final construction instead of being stated in advance as one would often usually do.

\begin{definition}[Proof mode]
The \textbf{proof mode} is a contextualized representation of a backward proof.
\end{definition}

The proof mode is stateful: commands can be applied to update the state. The history of commands is also stored and is used to generate the kernel proof.

\begin{definition}[Proof goal]
In proof mode, a \textbf{proof goal} corresponds to a sequent that remains to be proven.
\end{definition}

To enter proof it is required to provide an initial proof goal that will serve as an initial state to this proof mode.

\begin{definition}[Proof state]
In proof mode, the \textbf{proof state} is a stack of proof goals.
\end{definition}

A statement is said to be proven once the proof state becomes empty, or in other words once all proof goals have been eliminated.

\subsection{Tactics}

\subsubsection{Tactics combinators}

Although impractical, tactics can call other tactics when they are applied. Instead we provide a set of predefined combinators that can be used as higher-order tactics (figure \ref{fig:tactics-combinators}).

\begin{figure}[hbt!]
  \centering
  \begin{tabular}{||c c c c||}
  \hline
  \textbf{Combinator} & \textbf{Arity} & \textbf{Symbol} & \textbf{Semantic} \\
  \hline\hline
  Sequence & $\geq 1$ & $\sim$ & Applies all the tactics in sequence. \\ \hline
  Repetition & $1$ & $+$ & Repeats a tactic one or more times. \\ \hline
  Fallback & $\geq 1$ & $|$ & Applies the first tactic that does not fail. \\ \hline
  \end{tabular}
  \caption[Available combinators]{The main tactic combinators provided by the framework.}
  \label{fig:tactics-combinators}
\end{figure}

\subsection{Rules}


